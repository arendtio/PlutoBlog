<app class="m-app">
	<header>
		<header-buttons/>
	</header>
	<pages>
		<page pattern="home">
			<div class="home entry" each="{i in parent.parent.index}">
				<h1>{i.title}</h1>
				<!--<span>{(new Date(i.date)).toDateString()}</span>-->
				<div class="sd-content">
					<raw html="{ md2html(i.description, i.file) }"/>
				</div>
				<div class="divider">
					<a href="#posts/{encodeURIComponent(i.prettyId)}">More</a>
				</div>
			</div>
		</page>
		<page each="{post in parent.index}" pattern="posts/[prettyId]" url="posts/{encodeURIComponent(post.prettyId)}">
			<post file="{post.file}">
		</page>
	</pages>
	<aside>
		<br/>
		<br/>
		<img src="img/logo.svg"/>
		<br/>
		<br/>
		{ author }<br/>
		<br/>
		<raw html="{ md2html(description) }"/>
		<br/>
		<br/>
		<br/>
		<div class="footer">
			<a href="rss.xml"><img src="img/rss.svg"/> RSS Feed</a>
			<br/>
			<br/>
			<br/>
			<sub><a href="https://github.com/arendtio/PlutoBlog">Made with ♥ and ♇</a></sub><br/>
			<br/>
		</div>
	</aside>
	<div class="preload">
		<div class="spinner"></div>
	</div>


	<script>
	var tag = this
	tag.index = undefined;
	tag.selected = {};
	tag.author = "";
	tag.description = "";
	tag.routerStarted = false;
	tag.mountComplete = false;

	tag.animationController = new function(){
		var ctrl = this;
		ctrl.beforePageAnimation = function() {};
		ctrl.afterPageAnimation = function() {};
		ctrl.go = function(route, animation) {
			ctrl.beforePageAnimation();

			//animate

			var leaving=["-100%", "0%"]; // to -100% from 0%
			var incoming=["0%", "100%"]; // to 0% from 100%
			if(animation === "back"){
				leaving=["100%", "0%"];
				incoming=["0%", "-100%"];
			}

			// remove class
			var elCur = document.getElementsByClassName("page current");
			var elNext = document.getElementsByClassName("page next");
			var heightCur = 0;
			var heightNext = 0;


			// we need both pages to be display: block; to obtain
			// their height.
			// at the same time we should not set the pages to
			// position: absolute; because that might cause a scroll to top

			// keep the height of the page during animation
			var pages = document.getElementsByClassName("pages");
			var minHeight=0;
			if(elCur.length > 0){
				// current is always display: block;
				heightCur = elCur[0].offsetHeight;
				pages[0].setAttribute("style", "min-height: "+heightCur+"px;");
				addClass(elCur[0], "animating"); // this can trigger a scroll to top, if the min-height is not set
				minHeight=heightCur;
			}
			if(elNext.length > 0){
				// set display: Block;
				addClass(elNext[0], "animating");
				heightNext = elNext[0].offsetHeight;
				if(minHeight < heightNext) {
					pages[0].setAttribute("style", "min-height: "+heightNext+"px;");
					minHeight=heightNext;
				}
			}

			var dur = 500;

			// animate the aside out if the viewport
			var viewportHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
			if(viewportHeight > minHeight){
				Velocity(pages[0], {
					"min-height": [(document.body.scrollTop + viewportHeight) + "px", minHeight+"px"]
					}, { duration: dur });
			}

			// animate the current page
			if(elCur.length > 0){
				Velocity(elCur[0], {
					"translateX": leaving,
					"translateY": ["0px", "0px"]
				}, {
						duration: dur,
						complete: function() {
						}
					}
				);
			}

			// animate the next page
			if(elNext.length > 0){
				//elNext[0].setAttribute("style", "display: block;");
				//var style = "transform: translateY("+document.body.scrollTop+"px);"
				//pages[0].setAttribute("style", style);
				Velocity(elNext[0], {
					"translateX": incoming,
					"translateY": [document.body.scrollTop+"px", document.body.scrollTop+"px"]
				}, {
						duration: dur,
						complete: function() {
							if(elCur.length > 0) {
								//complete current
								removeClass(elCur[0], "animating");
								removeClass(elCur[0], "current");
							}

							// complete next
							elNext[0].setAttribute("style", "");
							addClass(elNext[0], "current");
							removeClass(elNext[0], "animating");
							// remove as last as it changes elNext[0]
							removeClass(elNext[0], "next");

							window.scrollTo(0, 0);

							// animate aside back to the viewport (for shorter next pages)
							Velocity(pages[0], {"min-height": elNext.offsetHeight + "px"
							}, {
								duration: dur,
								complete: function() {
								pages[0].setAttribute("style", "");
								//XXX: Do not start another animation before this has completed
							}});


							ctrl.afterPageAnimation();
						}
					}
				);
			}
		}
	}();

	tag.on("mount", function() {
		debug.log("tag-updates", 1, "app-tag mount");
		tag.author = document.head.querySelector("[name=author]").content;
		tag.description = document.head.querySelector("[name=description]").content;
		RiotControl.trigger("app_init");
	});

	tag.on("update", function() {
		debug.log("tag-updates", 1, "APP-TAG UPDATE");
	});

	tag.on("updated", function() {
		tag.routerStarter();
	});

	RiotControl.on("postindex_changed", function(index) {
		tag.index = index;
		tag.update();
	});

	RiotControl.on("init_mount_complete", function() {
		tag.mountComplete = true;
		tag.routerStarter();
	});

	RiotControl.on("prepare_page_change", function(currentUrl, targetUrl) {
		RiotControl.trigger("url_change", currentUrl, targetUrl);
	});

	tag.routerStarter = function() {
		if( tag.mountComplete && tag.index !== undefined){
			if( ! tag.routerStarted){
				tag.routerStarted = true;

				// start router
				RiotControl.trigger("register_animation_controller", tag.animationController);
				RiotControl.trigger("start_router", "home");
			}
		}
	}
	</script>

	<style>
		.page.animating {
			position: absolute;
			display: block;
		}
		.page {
			/*to have the same page size for display static as for absolute*/
			padding-top: 1px;
			padding-bottom: 1px;
		}
		.preload {
			position:absolute;
			z-index: -1;
			top: 0;
			left: 0;
			width: 1px;
			height: 1px;
			overflow: hidden;
		}
	</style>
</app>
